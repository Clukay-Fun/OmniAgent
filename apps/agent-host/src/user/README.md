# User (用户身份与权限域)

`user/` 目录负责整个系统的用户身份识别、权限绑定以及通讯录关联。

本模块深受 `nanoclaw` 的降维设计启发。在原本的 OpenClaw 重型架构中，用户权限通常伴随复杂的 RBAC（基于角色的权限控制）或 ABAC模型，甚至需要外置的统一身份认证服务（如 LDAP 或 OIDC Webhook）。但在当前基于飞书协同群聊的敏捷语境下，我们采取了极度轻薄的“自动协商 + 懒加载缓存”身份核实策略。

## 目录模块解析

该目录由三个轻量级组件闭环配合，完成从**未知消息者**到**授权业务人员**的身份转换：

- **`manager.py` (用户信息集散中心)**
  - Agent 大脑认知用户的唯一入口。
  - **链路设计**：接收到新请求后，先读取内置 `UserCache`。如未命中，则直接调用底层 `feishu_api` 的 `contact/v3/users/{open_id}` 接口实时抓取该人员在飞书通讯录里的真实姓名和手机号等底座数据。
  - **职责前置**：除了获取组织架构属性，Manager 还会立刻触发下游 `UserMatcher`，尝试将其飞书真名与业务大库（如飞书多维表格中的“案件表”）关联起来。如果关联成功，当前发消息的“李四”就被打上了“有权处理案件的主办律师/协办律师”的思想钢印。

- **`matcher.py` (动态身份匹配器)**
  - **泛用探测**：它没有硬编码固定查询表，而是接受 `UserManager` 从 `skills.yaml` 初始化时灌入的 `table_identity_fields`（如“主办律师”、“协办律师”等阵列）。通过向 `MCPClient` 发起 `search_exact` 工具调用，实现在多维表格海量数据里校验该人名的合法性。
  - 在匹配算法上，只要任意一个预设字段触发非空记录（`total > 0`），即视为拥有高置信度的内部人员。

- **`cache.py` (内存态身份池)**
  - 一个轻量级的、纯 Python `dict` 实现的带有 LRU 淘汰和 TTL 过期的高性能内存缓存 (`UserCache`)。
  - **核心价值**：保护飞书开放平台通讯录 API 不被高频的同一群聊对话搞垮限流，同时减少发起检索大库（MCP 调用）的资源压力。通过控制 `ttl_hours` 还能定期强迫 Agent 遗忘老旧身份重新查验。

---

## 架构提议 (Implementation Protocol)

### OpenClaw 视角 (正统架构基准)
在 OpenClaw 的大规模集群理念下，User Identity 属于全局共享状态。`UserCache` 绝对不被允许写死在本地内存中，而是必须接入如 Redis 之类的分布式 KV 存储，匹配记录也会下发一层独立的 RBAC 库与 Policy 库。

### Nanoclaw 映射 (本项目降维实现)
作为直接嵌入团队协作平面的“微型大脑”（Nanobot 理念）：
1. **拥抱业务强绑定**：我们没有单独构建“权限中心表”，而是通过 `matcher.py` 极其灵活地“利用飞书案件本表的`人员字段`来倒推权限”。你在表里是主办律师，你在这个 Agent 面前就是合法权限人。极大压缩了后台研发成本，这叫 **Permission by Data**。
2. **拒绝分布式强迫症**：用 `UserCache` 这个在进程内带 LRU 控制的本地字典做 Cache。为什么不用 Redis？因为我们目前的请求规模并未超过单节点的 CPU 边界。如果哪天需要水平扩展 Pod，直接平替这个 Cache 的 backend 为一套简单的异步 Redis KV 即可，因为在 `manager.py` 的调用层，它只是调用 `.get()` 和 `.set()`。
